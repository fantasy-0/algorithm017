学习笔记

一、位运算

（1）计算机当中是以补码的形式进行存储，因此位运算也是针对与补码进行的操作，常用的位运算有以下几种：
	
	(1.1)<<（左移）：所有的数字往左边移动，左边出界的数字舍弃，右多出来的位置用0填充
	
	>>（右移）：所有的数字往右边移动，左边多出来的位置用0填充，右边出界的数字舍弃
	
	&（逻辑与）：同时为1结果才是1，其他情况是0
	
	|（逻辑或）：只有同时为0，结果才是0，其他情况结果是1
	
	^（逻辑异或）：做异或的两个数字不相同，结果才是1，其他情况结果是0
	
	x & 1 ：求最右边的数字
	
	x & (x - 1) ：将最低位的1置零
	
（2）正数的反码、补码都是为原码

（3）负数的反码、补码求解

	（3.1）负数的反码由原码符号位不变，其他位取反求得；
	
	（3.2）负数的补码由负数的反码加一求得。

二、布隆过滤器

（1）布隆过滤器是将一个key通过特定的函数转化为二进制数字存储在内存当中，如果最查找key的时候，生成的二进制对应位置的1在内存当中不存在，则这个key肯定是不存在的，如果生成的二进制对应位置的1在内存当中都存在，只能说此key可能存在，一般运用于做缓存，通过了布隆过滤器才会进行数据库查询。

三、排序算法

（1）基础排序算法：

    ```java
    /**
     * 时间复杂度o(n^2)
     * 空间复杂度o(1)
     *
     * 冒泡排序:假设从小到大排序，首先遍历整个数组找到最大元素放到最后，
     * 接着又从头开始遍历到倒数第二个最大的放最后，直到整个数组有序停止排序
     * @param data
     */
    public void bubbleSort(int data[]) {
        if (data == null || data.length < 2) {
            return;
        }

        for (int i = 0; i < data.length - 1; i++) {
            for (int j = 0; j < data.length - 1 - i; j++) {
                if (data[j] > data[j + 1]) {
                    int temp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = temp;
                }
            }
        }
    }

    /**
     * 时间复杂度为o(n^2)
     * 空间复杂度为o(1)
     * 插入排序：假设从小到达排序，首先第一个元素为有序的，接着再插入第二个元素，
     * 从后往前比较直到找到比自己小的元素插入，或者到数组头部，接着继续从第三个
     * 元素开始往前找到合适的位置放下去，直到所有元素插入完成，停止排序。
     * @param data
     */
    public void insertionSort(int data[]) {
        if (data == null || data.length < 2) {
            return;
        }

        int end = 0;//用来记录当前有序数组的结尾索引
        //第一个元素有序，从第二个元素依次插入
        for (int i = 1; i < data.length; i++) {
            int cur = data[i];//当前插入的元素
            int index = end;
            //找到插入元素的位置
            while (index >= 0 && data[index] > cur) {
                data[index + 1] = data[index];
                index--;
            }

            data[index + 1] = cur;
            end = i;
        }
    }

    /**
     * 时间复杂度为o(n^2)
     * 空间复杂度为o(1)
     * 选择排序：假设从小到达排序，首先，下标指向第一个元素，找到比第一个元素还小的元素，那么将下标交换，
     * 直接遍历所有元素，发现交换了下标，则将最小的元素与第一个元素替换，接着从第二个元素开始，继续，
     * 直到最后一个元素也排好序结束。
     * @param data
     */
    public void selectionSort(int data[]) {
        if (data == null || data.length < 2) {
            return;
        }

        for (int i = 0; i < data.length - 1; i++) {
            int index = i;
            for (int j = i + 1; j <= data.length - 1; j++) {
                if (data[j] < data[index]) {
                    index = j;
                }
            }

            if (index != i) {
                int temp = data[index];
                data[index] = data[i];
                data[i] = temp;
            }
        }
    }
    ```

（2）高级排序算法
	
	（2.1）快速排序：首先寻找一个标兵，将数组一分为二，左边全部小于标兵、右边全部大于标兵，继续将标兵左边的数组进行快排、标兵右边的数组进行快排，最终整个数组有序。时间复杂度为o(n*logn)，

	（2.1.1）如果数组有序，时间复杂度会退化为o(n^2)

	（2.2）堆排序：首先建堆，时间复杂度为o(n),接着取堆顶元素放入数组末尾，取数组末尾元素放入堆顶，重新调整堆，时间复杂度为o(logn),调整好后继续取堆顶元素放入数组倒数第二个位置，倒数第二个元素放到堆顶，直到堆为空，则排好序了，时间复杂度为o(n * logn)。
	 
	（2.2.1）缺点：由于排序，访问元素内存地址跳动大，对于内存不友好。

	（2.3）归并排序：将一个数组划分为2个，然后比较第一个谁小谁先放，继续比较未保存的元素，直到全部比较完成。

	（2.4）希尔排序：首先将步长为length/2的元素进行插入排序，接着将length/4的元素进行排序，直到length/(2^n)为0，排序结束。

	（2.5）计数排序：确定排序数组的取值范围，接着定义一个那么大的数组A，然后遍历原始数组，在对应数组A当中对应位置+1，计数完成之后再顺序遍历数组A,值不为0，则塞入原始数组，并且index++,将数组A对应的值--，直到为0，继续下一个值，遍历A完成，原始数组有序。

	（2.6）基数排序：首先取个位，放入0-9数组中，接着取出来，又根据十位，继续依次放入0-9数组中，继续取出来，直到取到数组当中最高位位置，排序结束。

	（2.7）桶排序：工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）
	
