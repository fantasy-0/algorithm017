学习笔记
一.HashMap小结
  HashMap 是非线程安全的，基于哈希表的 Map 接口实现。并且允许存储 null 值和 null 键。
  当存储一个键值对的时候，首先会拿着 key 根据相应的哈希算法获取到 key 的哈希值，然后检查数组哈希值对应位置是否为 null，如果为 null 则直接将此键值对存入，如果不为 null，则看下当前存入的 key 是否已存入，已存入，则替换 value 的值，未存入，则存入到哈希值对应数组位置元素的链表最后的节点(在jdk1.8已经修改链表为红黑树)。

二.自学堆排序
  堆排序这里说的是二叉堆的堆排序（假设降序，使用小顶堆）。

  （1）第一步建堆，从最后一个非叶子结点开始，找出非叶子与叶子结点三个当中最小值。
  假如发生替换，则需要看下替换后的值与它的叶子结点继续比较，直到最后一层。
  假如没有发生替换，则继续找按照最后一个非叶子结点的方式处理倒数第二个非叶子结点，一直处理到根，那么堆就建造好了，建堆的时间复杂度为o(n),空间复杂度为o(1)。

  （2）第二步排序，第一步已建好堆了，如果是降序，那么使用小顶堆，取出根结点，放入数组最后的位置，将最后的一个结点放入根的位置，然后继续，将根与它的两个子结点比较，找出最小值，如果没有发生替换，则已经是堆继续取根放入倒数第二个位置，如果发生了替换，则继续拿替换后的位置与它的子结点比较，直到堆重新建造好，又继续取数字放入数组最后，每次取出一个值，数组需要减一，直到数组长度为0，那么排序完成。时间复杂度为o(n * log(2)(n))其中n代表节点数，空间复杂度为o(1)。

三.学习小结：
  通过本周的课程学习，了解了以下知识点：
  1.了解了完全二叉树，满二叉树的一些性质，结点i的，左叶子结点为2*i + 1,右叶子结点为2*i + 2，满二叉树的高度为H，则叶子结点总数为2^H-1个。

  2.学习到了堆这种数据结构，并且了解的堆的完全二叉树这种实现方式以及堆排序，大顶堆（所有子树小于根结点），小顶堆（所有子树大于根结点）的建造，建堆的时间复杂度为什么为n。二叉堆的插入，在最后一个位置插入，然后依次冒泡直到根结点即可，二叉堆的删除，将最后一个叶子结点替换删除的根，并且数组长度减1，然后依次下沉，直接下沉到树高即可。

  3.学习了HashMap的实现原理

  4.了解到了狄杰斯特拉算法求解最小路径过程：首先选择一个点出发，将其存入小顶堆中(PriorityQueue),接着取出根，以及与根所有连接没有被遍历的点放入堆中，如果当前根到点的距离+根到起点的距离<当前点记录到起点的距离，则将当前点记录的父结点替换为根，这个根所有的子结点操作完记录此根已遍历过，一直到堆为空，则遍历结束，输出记录到起点距离的表，则可以知道各个点到起点最短路径为多少。

  5.了解到了平衡二叉树，所有的左子树小于根结点，所有的右子树均大于根结点。